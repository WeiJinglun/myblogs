# 数据结构基础学习(三)

1.  基本的排序算法
    -   冒泡排序
    -   插入排序
2.  常考的排序算法
    -   归并排序
    -   快速排序
    -   拓扑排序
3.  其他排序
    -   堆排序
    -   桶排序

**注意：**

1.  冒泡排序和插入排序是最基础的，面试官有时候喜欢拿它们来考察你的基础知识，并且看看你能不能快速地写出没有bug的代码。
2.  归并排序、快速排序和拓扑排序的思想是解决绝大部分设计排序问题的关键。
3.  堆排序和桶排序，在一定的场合中，能在线性时间复杂度里解决战斗。

## 冒泡排序（Bubble Sort）

#### **基本思想**

给定一个数组，我们把数组里的元素通通倒入到水池中，这些元素将通过相互之间的比较，按照大小顺序一个一个地像水泡一样浮出水面。

#### **实现**

每一轮，从杂乱无章的数组头部开始，每两个元素比较大小并进行交换，直到这一轮当中最大或最小的元素被安置在数组的尾部，然后不断地重复这个过程，直到所有元素都排好位置。其中，核心操作就是元素相互比较。

#### **例题分析**

给定数组[2，1，7，9，5，8]，要求按照从左到右、从小到大的顺序进行排序。

#### **解题思路**

从左到右依次冒泡，把较大的数往右边挪动即可。

![img](img/冒泡排序.gif)

1.  首先指针指向第一个数，比较第一个数和第二个数的大小，由于2比1大，所以两两交换，[1，2，7，9，5，8]。
2.  接下来指针往前移动一步，比较2和7，由于2比7小，两者保持不动，[1，2，7，9，5，8]。到目前为止，7是最大的那个数。
3.  指针继续往前移动，比较7和9，由于7比9小，两者保持不动，[1，2，7，9，5，8]。现在，9变成了最大的那个数。
4.  再往后，比较9和5，很明显，9比5大，交换它们的位置，[1，2，7，5，9，8]。
5.  最后，比较9和8，9比8大，交换它们的位置，[1，2，7，5，8，9]。经过第一轮的两两比较，9这个最大的数就像冒泡一样冒到了数组的最后面。

接下来进行第二轮的比较，把指针重新指向第一个元素，重复上面的操作，最后，数组变成了：[1，2，5，7，8，9]。

在进行新的一轮的比较中，判断一下在上一轮比较的过程中有没有发生两两交换，如果一次交换都没有发生，就证明数组已经排好序了。

#### **代码实现**

```java
		public void bubbleSort(int[] nums) {
        //定义一个布尔变量 hasChange，用来标记每轮遍历中是否发生了交换
        boolean hasChange = true;
        
        //每轮遍历开始，将hasChange设置为false
        for (int i = 0; i < nums.length - 1 && hasChange; i++) {
            hasChange = false;
            
            //进行两两比较，如果发现当前的数比下一个数还大，那么就交换这两个数，同事记录一下有交换发生
            for (int j = 0; j < nums.length - 1 - i; j++) {
                if (nums[j] > nums[j + 1]) {
                    swap(nums, j, j + 1);
                    hasChange = true;
                }
            }
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
```

#### 算法分析

##### 空间复杂度

假设数组的元素个数是n，由于在整个排序的过程中，我们是直接在给定的数组里面进行元素的两两交换，所以空间复杂度是O(1)。

##### 时间复杂度

1.  给定的数组按照顺序已经拍好

    在这种情况下，我们只需要进行n-1次的比较，两两交换次数为0，时间复杂度是O(N)。这是最好的情况。

2.  给定的数组按照逆序排列

    这种情况下，我们需要进行n(n-1)/2次比较，时间复杂度是O(N^2^)。则是最坏的情况。

3.  给定的数组杂乱无章

    在这种情况下，平均时间复杂度为O(N^2^)。

由此可见，冒泡排序的时间复杂度是O(N^2^)。它是一种**稳定的排序算法**。（稳定是指如果数组里两个相等的数，那么排序前后这两个相等的数的相对位置保持不变。）

## 插入排序（Insertion Sort）

#### 基本思想

不断地将尚未排好序的数插入到已经排好序的部分。

#### 特点

在冒泡排序中，经过每一轮的排序处理后，数组后端的数是排好序的；而对于插入排序来说，经过每一轮的排序处理后，数组前端的数都是排好序的。

#### 例题分析

对数组[2，1，7，9，5，8]进行插入排序。

#### 解题思路

首先将数组分成左右两个部分，左边是已经排好序的部分，右边是还没有排好序的部分，刚开始，左边已经排好序的部分只有第一个元素2。接下来，我们对右边的元素一个一个进行处理，将它们放到左边。

![img](img/插入排序.gif)

1.  先来看1，由于1比2小，需要将1插入到2的前面，做法很简单，两两交换位置即可，[1，2，7，9，5，8]。
2.  然后，我们要把7插入到左边的部分，由于7已经比2大了，表明它是目前最大的元素，保持位置不变，[1，2，7，9，5，8]。
3.  同理，9也不需要做位置变动，[1，2，7，9，5，8]。
4.  接下来，如何把5插入到合适的位置。首先比较5和9，由于5比9小，两两交换，[1，2，7，5，9，8]，继续，由于5比7小，两两交换，[1，2，5，7，9，8]，最后由于5比2大，此轮结束。
5.  最后一个数是8，由于8比9小，两两交换，[1，2，5，7，8，9]，再比较7和8，发现8比7大，此轮结束。至此，插入排序完毕。

#### 代码实现

```java
public void insertionSort(int[] nums) {
        // 将数组的第一个元素当作已经排好序的，从第二个元素，即 i 从 1 开始遍历数组
        for (int i = 1, j, current; i < nums.length; i++) {
            //外围循环开始，把当前 i 指向的值用 current 保存
            current = nums[i];

            //指针j内循环，和current值比较，若j所指向的值比current值大，则该数右移一位
            for (j = i - 1; j >= 0 && nums[j] > current; j--) {
                nums[j + 1] = nums[j];
            }

            //内存循环结束，j+1 所指向的位置就是 current 值插入的位置
            nums[j + 1] = current;
        }
    }
```

#### 算法分析

##### 空间复杂度

假设数组的元素个数是n，由于在整个排序的过程中，是直接在给定的数组里面进行元素的两两交换，空间复杂度是O(1)。

##### 时间复杂度

1.  给定的数组按照顺序已经排好

    只需要进行n-1次的比较，两两交换次数为0，时间复杂度是O(N)。这是最好的情况。

2.  给定的数组按照逆序排列

    这种情况下，我们需要进行n(n-1)/2次比较，时间复杂度是O(N^2^)。则是最坏的情况。

3.  给定的数组杂乱无章

    在这种情况下，平均时间复杂度为O(N^2^)。

由此可见，和冒泡排序一样，插入排序的时间复杂度是 O(n2)，并且它也是一种**稳定的排序算法**。

